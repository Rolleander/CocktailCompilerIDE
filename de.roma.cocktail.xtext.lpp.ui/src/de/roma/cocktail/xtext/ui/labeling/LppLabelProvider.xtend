/*
 * generated by Xtext 2.9.1
 */
package de.roma.cocktail.xtext.ui.labeling

import com.google.inject.Inject
import de.roma.cocktail.xtext.lpp.Begin
import de.roma.cocktail.xtext.lpp.Close
import de.roma.cocktail.xtext.lpp.Export
import de.roma.cocktail.xtext.lpp.Global
import de.roma.cocktail.xtext.lpp.GrammarRules
import de.roma.cocktail.xtext.lpp.Import
import de.roma.cocktail.xtext.lpp.Local
import de.roma.cocktail.xtext.lpp.ParserName
import de.roma.cocktail.xtext.lpp.Precedence
import de.roma.cocktail.xtext.lpp.PrecedenceRow
import de.roma.cocktail.xtext.lpp.ScannerName
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider
import org.eclipse.jface.preference.JFacePreferences
import org.eclipse.jface.viewers.StyledString
import org.eclipse.jface.viewers.StyledString.Styler
import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider
import de.roma.cocktail.xtext.lpp.Parser

/**
 * Provides labels for EObjects.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#label-provider
 */
class LppLabelProvider extends DefaultEObjectLabelProvider {

		val Styler styleBlue=StyledString.createColorRegistryStyler(JFacePreferences.ACTIVE_HYPERLINK_COLOR,null);

	@Inject
	new(AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}

	// Labels and icons can be computed like this:
	def image(Parser p) {
		'parser.png'
	}

	def text(Parser p) {
		'Parser'
	}

	def image(Import o) {
		'cog.png'
	}

	def text(Import o) {
		'Import'
	}

	def image(Export o) {
		'cog.png'
	}

	def text(Export o) {
		'Export'
	}

	def image(Global o) {
		'cog.png'
	}

	def text(Global o) {
		'Global'
	}

	def image(Local o) {
		'cog.png'
	}

	def text(Local o) {
		'Local'
	}

	def image(Begin o) {
		'cog.png'
	}

	def text(Begin o) {
		'Begin'
	}

	def image(Close o) {
		'cog.png'
	}

	def text(Close o) {
		'Close'
	}
	
//		def image(Tokens o)
//	{
//		'tokens.png'
//	}
//	
//	def text(Tokens o)
//	{
//		'Tokens'
//	}
//	
//	def image(DefinedToken o)
//	{
//		'token.png'
//	}
//	
//	def text(DefinedToken o)
//	{
//	 o.getName()+': '+o.getNumber()	
//	}
//	
	def image(Precedence o)
	{
		'star.png'
	}
	
	def text(Precedence o)
	{
		'Precedences'
	}
	
	
	 def image(PrecedenceRow o)
	{
		switch(o.type)
		{
			case LEFT: 'arrow_left.png'
			case NONE: 'stop.png'
			case RIGHT: 'arrow_right.png'
		}
	}
	
//	def text(PrecedenceRow o)
//	{
//		val tokens=o.getTokens()
//	    var returnText=''
//	    for(t: tokens)
//	    {
//	    	returnText+=t.getName()+' '
//	    }
//		return returnText
//	} 
	
	 def image(ScannerName o)
	{
		'barcode.png'
	}
	
	def text(ScannerName o)
	{
		'Scanner: '+o.getName()
	} 
	
	
		 def image(ParserName o)
	{
		'key.png'
	}
	
	def text(ParserName o)
	{
		'Name: '+o.getName()
	}
	
		 def image(GrammarRules o)
	{
		'rules.png'
	}
	
	def text(GrammarRules o)
	{
		'Grammar Rules'
	} 
	
//	def image(GrammarRule o)
//	{
//		'text_replace.png'
//	}
//	
//	def text(GrammarRule o)
//	{
//		o.getName()
//	} 
//	
//	 def image(RuleBody o)
//	{
//		'page.png'
//	}
//	
//	
//	
//	def text(RuleBody o)
//	{
//		val part=o.part
//		val contents=part.content
//		var text=new StyledString
//		for(c: contents)
//		{
//			val reg=c.regex
//			val ref=c.ref
//			if(reg!=null){
//				text.append(reg+" ")
//			}
//			if(ref!=null)
//			{
//				text.append(ref.name+" ",styleBlue)
//			}
//		}
//		
//		return text;
//	} 
	
	
	
	/*	 	 
	 def image( o)
	{
		'.png'
	}
	
	def text( o)
	{
		''
	} 
 
	 */
}
